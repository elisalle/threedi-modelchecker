- Start Date: 2021-02-15
- RFC PR: https://github.com/nens/threedi-modelchecker

# Summary

Add a method to migrate databases between different versions of the model
definition (schema).

# Basic examples

Initialisation:

```
>>> from threedi_modelchecker import ThreediDatabase
>>> db = ThreediDatabase({"db_path": "/path/to/sqlite"})
```

A database knows what version it has:

```
>>> db.get_version()
0007
```

Allows inplace upgrading/downgrading schematisation versions:

```
>>> db.upgrade("head")
>>> db.downgrade(revision="0005")
```

Can list differences between the current schematisation and database:

```
>>> db.compare_schema()
[('remove_table', Table(u'bar', ...),
 ('add_column', None, 'foo', Column('data', Integer(), table=<foo>)),
]
```

Supports a method for the developer to autogenerate migrations based on a new
schematisation and a database that is up-to-date with the latest migration:

```
alembic revision --autogenerate -m "Added account table"
```

Autogenerated migrations will always need to be validated by hand.

# Motivation

There already is a method to migrate between different versions of the model
definition at https://github.com/nens/threedi/tree/master/lib/threedi-tools/threedi_tools .
We cannot keep working with this implementation; it is written using Django 1.6
and south, which didn't receive updates since 2014.

To make this code mainainable and to run it in current Python environments, we
need a new design.

# Detailed design

We will use Alembic to keep track of schema revisions and to run migrations.
Although Alembic main use is from the command line and with 1 statically
configured database, it is very flexible and also supports our use case.

### Migrating

It is not necessary to use the commandline to start migrations.
The relevant commands ``upgrade()``, ``downgrade()`` and ``current()`` are 
all part of the public Alembic API and can be accessed from Python.

See: https://alembic.sqlalchemy.org/en/latest/api/commands.html

### Revisions

Revisions are stored in a so-called "Migration Environment" which has a 
folder structure like this::

```
yourproject/
    alembic/
        env.py
        script.py.mako
        versions/
            3512b954651e_add_account.py
            2b1ae634e5cd_add_order_id.py
            3adcc9a56557_rename_username_field.py
```

The revision versions are unordered by default. We can however control the
revision number manually. We should try to force a linear history by using an
increasing number ``0001``, ``0002`` etc as reversion version identifiers.

The ``env.py`` implements methods to connect to the database. This is possibly
not necessary (to be investigated) because we will manage connections ourselves
through the existing ``ThreediDatabase`` class. This also goes for the
``alembic.ini`` file (containing things like database address). We should define
this from the code.

The ``script.py.mako`` is a template for new revisions. See next section.

The reserved revision identifier ``"head"`` corresponds to the schema currently
checked in to this repository. The latest migration in ``alembic/versions`` must
always match the state of the schema in ``threedi_modelchecker/threedi_model``.

### Creating a revision

This creates an empty file based on the ``script.py.mako``::

```
alembic revision -m "create account table"
```

This creates a candidate revision file based on a change in the schema
definition and a database that is in the latest revision state::

```
alembic revision -m --autogenerate "create account table"
```

The file contains an ``upgrade`` and ``downgrade`` functions. These should be
written/validated by hand by the developer making use of Alembic operations. See
https://alembic.sqlalchemy.org/en/latest/autogenerate.html and 
https://alembic.sqlalchemy.org/en/latest/ops.html#ops.


### The initial revision

The migrations should be able to create a new database from scratch. This means
that the initial migration will contain the complete schema of the database.

This migration should 'work' for legacy databases as well as for empty database
files.

# Drawbacks

The drawback of using Alembic is that migrations are written in a language
that is yet unknown to our developers.

# Alternatives

There is no alternative if we want to keep using SQLAlchemy for our schema.
The only other migration framework in Python is Django, which we do not want
to use (see RFC 0001)

# Adoption strategy

The current 172 migrations should be put in a specialized docker container, so
that they can be used for older databases. This repository starts with a fresh
revision history. 

# How we teach this

A README in this project will suffice.
