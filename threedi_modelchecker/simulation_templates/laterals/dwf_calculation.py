"""
/***************************************************************************
 Dry Weather Flow (DWF) Calculator

 Calculate DWF
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-01-27
        copyright            : (C) 2021 by Nelen en Schuurmans
        email                : daan.vaningen@nelen-schuurmans.nl
 ***************************************************************************/

"""
from threedi_modelchecker.simulation_templates.exceptions import (
    SchematisationError,
)
from typing import List
from typing import Optional
from typing import Union

import csv
import datetime
import sqlite3
import re


# Default values
DWF_FACTORS = [
    [0, 0.03],
    [1, 0.015],
    [2, 0.01],
    [3, 0.01],
    [4, 0.005],
    [5, 0.005],
    [6, 0.025],
    [7, 0.080],
    [8, 0.075],
    [9, 0.06],
    [10, 0.055],
    [11, 0.05],
    [12, 0.045],
    [13, 0.04],
    [14, 0.04],
    [15, 0.035],
    [16, 0.035],
    [17, 0.04],
    [18, 0.055],
    [19, 0.08],
    [20, 0.07],
    [21, 0.055],
    [22, 0.045],
    [23, 0.04],
]


def get_dwf_factors_from_file(file_path: str) -> List[Union[int, float]]:
    dwf_factors = []
    with open(file_path) as csv_file:
        reader = csv.reader(csv_file, delimiter=",")
        for row in reader:
            dwf_factors += [[int(row[0]), float(row[1])]]

    return dwf_factors


def start_time_and_duration_to_dwf_factors(
    start_time: str, duration: int, dwf_factors: Optional[List[Union[int, float]]]
) -> List[Union[int, float]]:
    starting_time = datetime.datetime.strptime(start_time, "%H:%M:%S")

    # First timestep at 0 seconds
    current_hour = starting_time.hour
    dwf_factor_per_timestep = [[0, dwf_factors[starting_time.hour % 24][1]]]

    for second in range(1, duration + 1):
        time = starting_time + datetime.timedelta(seconds=second)
        if time.hour != current_hour:
            dwf_factor_per_timestep.append([second, dwf_factors[time.hour % 24][1]])
        elif second == duration:
            dwf_factor_per_timestep.append([second, dwf_factors[time.hour % 24][1]])

        current_hour = time.hour

    return dwf_factor_per_timestep


def read_dwf_per_node(spatialite_path: str) -> List[Union[int, float]]:
    """Obtains the DWF per connection node per second a 3Di model sqlite-file."""

    conn = sqlite3.connect(spatialite_path)
    cursor = conn.cursor()

    # Create empty list that holds total 24h dry weather flow per node
    dwf_per_node_per_second = []

    # Create a table that contains nr_of_inhabitants per connection_node and iterate over it
    for row in cursor.execute(
        """
        WITH imp_surface_count AS
            ( SELECT impsurf.id, impsurf.dry_weather_flow,
                     impsurf.dry_weather_flow * impsurf.nr_of_inhabitants AS weighted_flow,
                     impsurf.nr_of_inhabitants / COUNT(impmap.impervious_surface_id) AS nr_of_inhabitants
             FROM v2_impervious_surface impsurf, v2_impervious_surface_map impmap
             WHERE impsurf.nr_of_inhabitants IS NOT NULL AND impsurf.nr_of_inhabitants != 0
             AND impsurf.id = impmap.impervious_surface_id GROUP BY impsurf.id),
        inhibs_per_node AS (
            SELECT impmap.impervious_surface_id, impsurfcount.nr_of_inhabitants,
                   impmap.connection_node_id, impsurfcount.dry_weather_flow, impsurfcount.weighted_flow
            FROM imp_surface_count impsurfcount, v2_impervious_surface_map impmap
            WHERE impsurfcount.id = impmap.impervious_surface_id)
        SELECT ipn.connection_node_id, SUM(ipn.nr_of_inhabitants), SUM(ipn.weighted_flow)
        FROM inhibs_per_node ipn GROUP BY ipn.connection_node_id
        """
    ):
        connection_node_id, nr_of_inhabitants_sum, weighted_flow_sum = row
        # DWF per person example: 120 l/inhabitant / 1000 = 0.12 m3/inhabitant
        dwf_per_node = (
            nr_of_inhabitants_sum * (weighted_flow_sum / nr_of_inhabitants_sum) / 1000
        )
        dwf_per_node_per_second.append([connection_node_id, dwf_per_node / 3600])

    conn.close()

    return dwf_per_node_per_second


def generate_dwf_lateral_json(
    spatialite_filepath: str, start_time: str, duration: int, dwf_factors: Optional[str]
) -> List[dict]:

    dwf_on_each_node = read_dwf_per_node(spatialite_filepath)
    dwf_factor_per_timestep = start_time_and_duration_to_dwf_factors(
        start_time=start_time, duration=duration, dwf_factors=dwf_factors
    )
    # Initialize list that will hold JSON
    dwf_list = []

    # Generate JSON for each connection node
    for dwf_node in dwf_on_each_node:
        dwf_per_timestep = """"""
        for row in dwf_factor_per_timestep:
            dwf_per_timestep = (
                dwf_per_timestep + str(row[0]) + "," + str(dwf_node[1] * row[1]) + "\n"
            )

        dwf_per_timestep = dwf_per_timestep[:-1]
        dwf_list.append(
            {
                "offset": 0,
                "interpolate": 0,
                "values": dwf_per_timestep,
                "units": "m3/s",
                "connection_node": dwf_node[0],
            }
        )

    return dwf_list


def dwf_json_to_csv(dwf_list: List[dict], output_csv_file: str) -> None:
    """Write DWF results to JSON."""
    with open(output_csv_file, "w", newline="") as csv_file:
        writer = csv.writer(csv_file)
        writer.writerow(["id", "connection_node_id", "timeseries"])
        for i, row in enumerate(dwf_list):
            connection_node_id = row["connection_node"]
            timeseries = row["values"]
            writer.writerow([str(i), str(connection_node_id), timeseries])


def str_to_seconds(time_str: str) -> int:
    """Get Seconds from time."""
    m, s = time_str.split(":")
    return int(m) * 60 + int(s)


class DWFCalculator:
    """Calculate dry weather flow (DWF) from sqlite."""

    def __init__(
        self,
        spatialite_path: str,
        start_time: str,
        duration: int,
        output_csv: str,
        dwf_progress_file: str = None,
    ) -> None:
        self.spatialite_path = spatialite_path
        self.start_time = start_time  # start time of day (HH:MM:SS) "00:00:00"
        self.duration = duration  # simulation duration (hours)
        self.output_csv = output_csv
        self.dwf_progress_file = dwf_progress_file  # path to csv

        # Validations
        if not isinstance(self.duration, int):
            try:
                self.duration = int(self.duration)
            except (ValueError, TypeError):
                raise SchematisationError(
                    "Duration should be an integer indicating"
                    "the simulation duration in hours."
                )

        for name, var in [
            ("spatialite_path", self.spatialite_path),
            ("start_time", self.start_time),
            ("output_csv", self.output_csv),
        ]:
            if not isinstance(var, str):
                raise SchematisationError(f"{name} should a string.")

        if not re.search("^\d\d\:\d\d:\d\d$", self.start_time):  # noqa
            raise SchematisationError("start_time should match HH:MM:SS format.")

    def process(self) -> None:
        """Process the input parameters."""
        if self.dwf_progress_file:
            dwf_factors = get_dwf_factors_from_file(self.dwf_progress_file)
        else:
            dwf_factors = DWF_FACTORS

        dwf_list = generate_dwf_lateral_json(
            spatialite_filepath=self.spatialite_path,
            start_time=self.start_time,
            duration=self.duration * 3600,
            dwf_factors=dwf_factors,
        )

        dwf_json_to_csv(dwf_list=dwf_list, output_csv_file=self.output_csv)
